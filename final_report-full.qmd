---
title: "Workload Model"
subtitle: "A summary of the workload model created for this organization"
title-block-banner: true
title-block-style: plain
format:
  html:
    toc: true
    toc-location: left
    toc-title: Contents
    css: styles.css
    code-fold: true
---


## Introduction

This report provides a summary view of data related to workers, tasks, and hours.

This report has been customized for American Rivers.

## Setup

### Environment


```{r setup}
#| message: false
here::i_am("final_report.qmd")
library(here)
library(ggplot2)
library(dplyr)
library(reactable)
library(reactablefmtr)
library(tippy)
library(ggh4x)
library(patchwork)
library(forcats)
library(tidytext)
library(ggrepel)

cfg <- config::get()

ggplot2::theme_set(theme_bw())

mbcol <- "#1D5F97"
my_pallette <- pals::kelly()[-1]

expandx = function(plot, expand, xmin=0) {

  max.x = max(layer_data(plot)$x, na.rm=TRUE)
  min.log = floor(log10(max.x))

  expand_limits(x=c(xmin, ceiling(max.x+expand)))
}

# TODO
# - add color pallette that aligns to malbay
# - add a label to work items graph to show what each mark means
# - figure out why rendering looks a little blurry
# - 90 degree angle of header row on heatmap or some other solution
# - Improve heatmap by
    # - making text smaller?
    # - Add tool tips with totals for columns and rows?
    # - 
# - After I get feedback on each view, start adding in data validation checks
# Can I adjust the scroll to scroll and not jump




# Random info: if prompted for gf pat, use the following two commands, I think
# gitcreds::gitcreds_set() # try just this... does it still ask?
# credentials::set_github_pat()

```

### Reading in Data

There is only a single data set used for this report.
It is organized by Task and Position. 
It provides information about each of these combinations and a quick summary is 
provided below. 

```{r data}

main_dat <- readxl::read_xlsx(here(cfg$datapath, cfg$client_main)) %>% 
  setNames(make.names(names(.)))

glimpse(main_dat)

```



:::{.callout-note}

A second data set could organize cases by tasks, 
with an estimate of how long each task should take. 
This data could be compared to the first data set throughout.


A third data set could provide a similar set of information, 
but summed at the role level.
Again, this data could be compared to the first data set throughout.

:::



```{r}

# # workitems_dat <- readr::read_csv(here(cfg$datapath, cfg$workitems),
# #                                  show_col_types = FALSE)
# 
# workitems_dat <- main_dat %>% 
#   select(Task, Total.Mins.Max, Department.Alignment) %>% 
#   group_by(Task, Department.Alignment) %>% 
#   summarize(Mins.Required = sum(Total.Mins.Max),
#             instances = n())
# 
# glimpse(workitems_dat)

```



```{r}

# workitems_dat <- readr::read_csv(here(cfg$datapath, cfg$workitems),
#                                  show_col_types = FALSE)

# role_dat <- main_dat %>% 
#   select(Current.Position, Total.Mins.Max) %>% 
#   group_by(Current.Position) %>% 
#   summarize(Total.Mins = sum(Total.Mins.Max),
#             Number.Tasks = n())
# 
# glimpse(role_dat)

```


## Preparing Data

This section outlines some data validation checks and a series of adjustments 
that are made to the input data based on global parameters. 

### Validating Data

:::{.callout-important}

This section is really meant for dealing with multiple data sets. 

*Are there any data validation steps we would want to include for this iteration?*


:::


Output from confirming data (probably a table)

- Number rows
- Total hours
- Total roles
- Total tasks
- Sum of planned hours should meet total number of fours after accounting for admin
- Sum of planned hours for each ind should meet expected supply, highlight above or below
- All individuals or roles should be included in the data set 
(placeholder inds can exist for planning)
- Sum of planned hours **within each period (week, month, year, etc.)** should
meet total number of hours after accounting for admin
- Sum of planned hours for **each individual or role within each period**
should meet total number of hours after accounting for administrative activities
- All tasks should be included, even if there is no alignment. 
The latter should be highlighted.
- Each ind's maximum and minimum dates should cover the full timeline. If they 
don't, the fact should be highlighted.

Some of the other generic ideas for this section could include:

- Overall timeline
- Standard work day/week/year
- Percent of worker's time that should be reserved for admin activities
- Total hours available after accounting for admin activities through the timeline
- Full list of workers/roles included in exercise
- Current quality level vs. optimal quality level

Other ideas?

### Adjusting Data

This section will outline any adjustments applied to the input data along with
a summary of any global parameters. 

A quick review of this data suggests a handful of adjustments. 
They include:

1. Adjust to hours
1. Add period column to represent period


```{r}

main_dat <-   main_dat %>% 
  mutate(Total.Hours = round(Total.Mins.Max / 60, 2),
         period = "week") %>% 
  mutate(Current.Position = stringr::str_replace(Current.Position, "Director", "Dir"),
         Current.Position = stringr::str_replace(Current.Position, "and", "&"),
         Current.Position = stringr::str_replace(Current.Position, "Technology", "Tech"))

color_dat <- unique(c(main_dat$Position.Specialty, main_dat$Operational.Function))
my_colors = my_pallette[1:length(color_dat)]
names(my_colors) <- color_dat


# Do I need this?
# workitems_dat <- main_dat %>% 
#   select(Task, Total.Hours, Department.Alignment) %>% 
#   group_by(Task, Department.Alignment) %>% 
#   summarize(Hours.Required = sum(Total.Hours),
#             Number.Tasks = n(),
#             .groups = "drop")
# role_dat <- main_dat %>% 
#   select(Current.Position, Total.Hours) %>% 
#   group_by(Current.Position) %>% 
#   summarize(Total.Hours = sum(Total.Hours),
#             Number.Tasks = n(), .groups = "drop")
```


:::{.callout-important}

OTHER IDEAS TO DISCUSS WITH TEAM:

1. Group tasks?

:::




## Views (Organized by Hours)

### Various Categories

This first summary view provides the sum of hours by a few different categories.

```{r deptmnt}
#| fig-width: 9
#| fig-height: 6
#| column: screen-inset-right

# prepare data
hours_by_ps <- main_dat %>% 
  group_by(Position.Specialty) %>% 
  summarize(Hours = sum(Total.Hours)) %>% 
  arrange(Hours)
  # mutate(Position.Specialty = forcats::fct_infreq(Position.Specialty, w = Hours))

hours_by_of <- main_dat %>% 
  group_by(Operational.Function) %>% 
  summarize(Hours = sum(Total.Hours)) %>% 
  arrange(Hours)

hours_by_sc <-  main_dat %>% 
  group_by(Scalability) %>% 
  summarize(Hours = sum(Total.Hours)) %>% 
  arrange(Hours)

hours_by_role <- main_dat %>% 
  group_by(Current.Position) %>% 
  summarize(Hours = sum(Total.Hours)) %>% 
  arrange(Hours)

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)

tl <- hours_by_ps %>% 
  ggplot(aes(y = forcats::fct_inorder(Position.Specialty))) +
  geom_col(aes(x = Hours), fill = my_pallette[3]) +
  labs(title = "...position specialty",
     y = NULL, 
     x = paste0('Hours per ', xlab)) + 
  # scale_fill_manual(values = my_pallette[2]) +
  theme(legend.position = "none")
  # scale_fill_brewer(palette = "Set3")

tr <- hours_by_of %>%
  ggplot(aes(y = forcats::fct_inorder(Operational.Function))) +
  geom_col(aes(x = Hours), fill = my_pallette[2]) +
  labs(title = "...operational function",
     y = NULL,
     x = paste0("Hours per ", xlab)) + 
  # scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none")

bl <- hours_by_sc %>% 
  ggplot(aes(y = forcats::fct_inorder(Scalability))) +
  geom_col(aes(x = Hours), fill = my_pallette[4]) +
  labs(title = "...scalability",
     y = NULL,
     x = paste0('Hours per ', xlab)) + 
  # scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none")

br <- hours_by_role %>% 
  ggplot(aes(y = forcats::fct_inorder(Current.Position))) +
  geom_col(aes(x = Hours), fill = my_pallette[5]) +
  labs(title = "...current position",
     y = NULL,
     x = paste0('Hours per ', xlab)) + 
  # scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none")

layout <- "
AAABBB
CCDDDD
"
# 
wrap_plots(A = tl, B = tr, C = bl, D = br, design = layout) + 
  plot_annotation(title = paste0("Hours per ", xlab, " by ...")) & 
  xlab(NULL)

# leftside
```



### Task, Position Specialty, and Scalability

#### Without Subtask

```{r tskpss}
#| fig-width: 8.5
#| fig-height: 12
#| column: screen-inset-right

# prepare data
hours_by_tps <- main_dat %>% 
  group_by(Task, Position.Specialty, Scalability) %>% 
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # mutate(Task = fct_rev(fct_infreq(Task, w = Hours))) %>% 
  mutate(Task = reorder_within(Task, Hours, Position.Specialty)) # to get the right ordering
  

graph <- hours_by_tps %>%
  # mutate(over_under_pct = Hours / Hours.Required-1) %>%
  # select(Task, Hours, Department.Alignment) %>%
  # ggplot(aes(y = forcats::fct_inorder(Task))) +
  ggplot(aes(y = Task, x = Hours)) +
  geom_col(aes(fill = Position.Specialty)) +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Position.Specialty), 
             cols = vars(Scalability),
             scales = "free_y", space = "free", 
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  scale_y_reordered() + # to get the right ordering
  labs(title = "Hours by task: position specialty, and scalability",
     y = "Task",
     x = paste0("Hours per ", xlab)) +
  scale_fill_manual(values = my_colors) + 
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0))

graph + expandx(graph, 2)
  
```
#### Tasks with a Subtask

```{r tskpssws}
#| fig-width: 8.5
#| fig-height: 6
#| column: screen-inset-right

# prepare data
hours_by_tps <- main_dat %>% 
  filter(!is.na(Subtask)) %>% 
  # mutate(Task = stringr::str_c(Task, ": ", Subtask)) %>%
  group_by(Task, Subtask, Position.Specialty, Scalability) %>% 
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # mutate(Task = fct_rev(fct_infreq(Task, w = Hours))) %>% 
  mutate(Subtask = reorder_within(Subtask, Hours, Position.Specialty)
    ) # to get the right ordering

hours_by_tps %>%
  # mutate(over_under_pct = Hours / Hours.Required-1) %>%
  # select(Task, Hours, Department.Alignment) %>%
  # ggplot(aes(y = forcats::fct_inorder(Task))) +
  ggplot(aes(x = Hours, y = Subtask)) +
  geom_col(aes(fill = Position.Specialty)) +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Position.Specialty, Task), 
             cols = vars(Scalability),
             scales = "free_y", space = "free", 
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  scale_y_reordered() + # to get the right ordering
  labs(title = "Hours by subtask: task, position specialty, and scalability",
     y = "Subtask",
     x = paste0("Hours per ", xlab)) +
  scale_fill_manual(values = my_colors) + 
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0))
  
```

### Task, Position Speciality, Current Position, and Scalability

#### Without Subtask

```{r tskpscps}
#| fig-width: 10
#| fig-height: 13
#| column: screen-inset-right


# prepare data
hours_by_tpscps <- main_dat %>%
  # full_join(workitems_dat %>% select(Task, Hours.Required), by = join_by(Task)) %>% 
  # filter(!is.na(Total.Hours)) %>% 
  group_by(Task, Current.Position, Position.Specialty, Scalability) %>%
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # full_join(workitems_dat) %>%
  mutate(Task = reorder_within(Task, Hours, list(Current.Position, Position.Specialty)))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# Create graph
graph <- hours_by_tpscps %>% 
  ggplot(aes(x = Hours, y = Task)) +
  geom_col(aes(fill = Position.Specialty), 
           position = "dodge")  +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Position.Specialty, Current.Position),
               cols = vars(Scalability),
             space = "free_y", scale = "free",
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by task: position speciality, current position, and scalability",
       y = "Task", 
       x = paste0("Hours per ", xlab)) +
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0)) +
  scale_y_reordered() +
  scale_fill_manual(values = my_colors)
  
graph + expandx(graph, 3)

```


#### Tasks with a Subtask

```{r tskpscpsws}
#| fig-width: 10
#| fig-height: 6
#| column: screen-inset-right


# prepare data
hours_by_tpscps <- main_dat %>%
  # full_join(workitems_dat %>% select(Task, Hours.Required), by = join_by(Task)) %>% 
  filter(!is.na(Subtask)) %>%
  group_by(Subtask, Task, Current.Position, Position.Specialty, Scalability) %>%
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # full_join(workitems_dat) %>%
  mutate(Subtask = reorder_within(Subtask, Hours, list(Current.Position, Position.Specialty)))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# Create graph
hours_by_tpscps %>% 
  ggplot(aes(x = Hours, y = Subtask)) +
  geom_col(aes(fill = Position.Specialty), 
           position = "dodge") +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Position.Specialty, Current.Position, Task),
               cols = vars(Scalability),
             space = "free_y", scale = "free",
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by subtask: task, position speciality, current position, and scalability",
       y = "Subtask", 
       x = paste0("Hours per ", xlab)) +
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0)) +
  scale_y_reordered() +
  scale_fill_manual(values = my_colors)

```



### Task, Operational Function, and Scalability

#### Without Subtask

```{r tskofs}
#| fig-width: 8.5
#| fig-height: 12
#| column: screen-inset-right

# prepare data
hours_by_tofs <- main_dat %>% 
  group_by(Task, Operational.Function, Scalability) %>% 
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  mutate(Task = reorder_within(Task, Hours, Operational.Function))

graph <- hours_by_tofs %>%
  # mutate(over_under_pct = Hours / Hours.Required-1) %>%
  # select(Task, Hours, Department.Alignment) %>%
  ggplot(aes(y = Task, x = Hours)) +
  geom_col(aes(fill = Operational.Function)) +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Operational.Function), 
             cols = vars(Scalability),
             scales = "free_y", space = "free", 
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by task: operational function, and scalability",
     y = "Task",
     x = paste0("Hours per ", xlab)) +
  scale_y_reordered()+
  scale_fill_manual(values = my_colors) + 
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0))
  
graph + expandx(graph, 3)

```

#### Tasks with a Subtask

```{r tskofsws}
#| fig-width: 8.5
#| fig-height: 6
#| column: screen-inset-right

# prepare data
hours_by_tofs <- main_dat %>% 
  filter(!is.na(Subtask)) %>% 
  group_by(Subtask, Task, Operational.Function, Scalability) %>% 
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  mutate(Subtask = reorder_within(Subtask, Hours, Operational.Function))

hours_by_tofs %>%
  # mutate(over_under_pct = Hours / Hours.Required-1) %>%
  # select(Task, Hours, Department.Alignment) %>%
  ggplot(aes(y = Subtask, x = Hours)) +
  geom_col(aes(fill = Operational.Function)) +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Operational.Function, Task), 
             cols = vars(Scalability),
             scales = "free_y", space = "free", 
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by subtask: task, operational function, and scalability",
     y = "Subtask",
     x = paste0("Hours per ", xlab)) +
  scale_y_reordered()+
  scale_fill_manual(values = my_colors) + 
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0))
  
```

### Task, Operational Function, Current Position, and Scalability

#### Without Subtask

```{r tskofscps}
#| fig-width: 10
#| fig-height: 12
#| column: screen-inset-right


# prepare data
hours_by_tpscps <- main_dat %>%
  # full_join(workitems_dat %>% select(Task, Hours.Required), by = join_by(Task)) %>% 
  # filter(!is.na(Total.Hours)) %>% 
  group_by(Task, Current.Position, Operational.Function, Scalability) %>%
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # full_join(workitems_dat) %>%
  mutate(Task = reorder_within(Task, Hours,
                               list(Current.Position, Operational.Function)))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# Create graph
graph <- hours_by_tpscps %>% 
  ggplot(aes(x = Hours, y = Task)) +
  geom_col(aes(fill = Operational.Function), 
           position = "dodge") +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Operational.Function, Current.Position),
               cols = vars(Scalability),
             space = "free_y", scale = "free",
             labeller = label_wrap_gen(width = 16, multi_line = TRUE)) +
  labs(title = "Hours by task: operational function, current position, and scalability",
       y = "Task", 
       x = paste0("Hours per ", xlab)) +
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0)) +
  scale_y_reordered() +
  scale_fill_manual(values = my_colors)

graph + expandx(graph, 3)
```
#### Tasks with a Subtask

```{r tskofscpsws}
#| fig-width: 10
#| fig-height: 6
#| column: screen-inset-right


# prepare data
hours_by_tpscps <- main_dat %>%
  filter(!is.na(Subtask)) %>% 
  # full_join(workitems_dat %>% select(Task, Hours.Required), by = join_by(Task)) %>% 
  # filter(!is.na(Total.Hours)) %>% 
  group_by(Subtask, Task, Current.Position, Operational.Function, Scalability) %>%
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # full_join(workitems_dat) %>%
  mutate(Subtask = reorder_within(Subtask, Hours,
                               list(Current.Position, Operational.Function, Task)))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# Create graph
hours_by_tpscps %>% 
  ggplot(aes(x = Hours, y = Subtask)) +
  geom_col(aes(fill = Operational.Function), 
           position = "dodge") +
  geom_text(aes(label = Hours), hjust = 0, size = 2.5) +
  facet_nested(rows = vars(Operational.Function, Current.Position, Task),
               cols = vars(Scalability),
             space = "free_y", scale = "free",
             labeller = label_wrap_gen(width = 16, multi_line = TRUE)) +
  labs(title = "Hours by subtask: task, operational function, current position, and scalability",
       y = "Task", 
       x = paste0("Hours per ", xlab)) +
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0)) +
  scale_y_reordered() +
  scale_fill_manual(values = my_colors)

```

### Heatmap

Finally, this view highlights where time is being spent by the team and 
where there are potential gaps.

```{r hm}
#| column: screen-inset-right

# https://glin.github.io/reactable/articles/examples.html#basic-usage

# TODO: 
# Add some data that takes into account higher level work tasks / skills
hm_dat <- main_dat %>% 
  mutate(`Task (Subtask)` = if_else(is.na(Subtask), Task, 
                        stringr::str_c(Task, " (", Subtask, ")"))) %>% 
  # filter(Current.Position == "Senior Accountant") %>% 
  select(`Task (Subtask)`, Total.Hours, Current.Position) %>% 
  group_by(`Task (Subtask)`, Current.Position) %>% 
  summarize(Total.Hours = sum(Total.Hours), .groups = 'drop') %>% 
  tidyr::pivot_wider(names_from = Current.Position, 
                     values_from = Total.Hours) %>% 
  as.data.frame()

hm_dat$`General Counsel`[1] <-  0 # need at least two items with a number
hm_dat$`CFO`[1] <-  0 # need at least two items with a number
 

with_tooltip <- function(value, tooltip, ...) {
  htmltools::div(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
      tippy(value, tooltip, ...))
}
library(htmltools)

reactable(hm_dat, 
          resizable = TRUE,
          pagination = FALSE,
          bordered = TRUE,
          wrap = FALSE,
                    # width = 2000,
          style = list(fontSize = "0.65rem"),
          defaultColDef = colDef(footer = function(values) sum(values, na.rm = T),
                                 footerStyle = list(fontWeight = "bold"),
                                 minWidth = 50,
                                 style = color_scales(hm_dat, 
                                                      colors = RColorBrewer::brewer.pal(5, "Oranges"))),
          columns = list(
            `Task (Subtask)` = colDef(minWidth = 150, filterable = TRUE, 
                         sticky = "left", footer = "Total"),
            # There must be a better way to do this...
            # cat(paste0("`", names(hm_dat),
            #            "` = colDef(header = with_tooltip('",names(hm_dat),
            #            "','",names(hm_dat),"'))"),
            #     sep = ",\n")
            # Maybe pass in a function to finish creating this table...?
            `Task (Subtask)` = colDef(header = with_tooltip('`Task (Subtask)`','`Task (Subtask)`')),
            `Junior Accountant` = colDef(header = with_tooltip('Junior Accountant','Junior Accountant')),
            `HR Director` = colDef(header = with_tooltip('HR Director','HR Director')),
            `Senior Accountant` = colDef(header = with_tooltip('Senior Accountant','Senior Accountant')),
            `Assistanct of HR and DEIJ` = colDef(header = with_tooltip(
              'Assistanct of HR and DEIJ','Assistanct of HR and DEIJ')),
            `Assoc Director of Contracts and HR` = colDef(header = with_tooltip(
              'Assoc Director of Contracts and HR','Assoc Director of Contracts and HR')),
            `Director of Grants and Financal Analysis` = colDef(header = with_tooltip(
                'Director of Grants and Financal Analysis','Director of Grants and Financal Analysis')),
            `Director of Facilities and Technology` = colDef(header = with_tooltip(
              'Director of Facilities and Technology','Director of Facilities and Technology')),
            `CFO` = colDef(header = with_tooltip('CFO','CFO')),
            `General Counsel` = colDef(header = with_tooltip('General Counsel','General Counsel'))
            )
          )
```


## Next Steps

:::{.callout-important}

Given limitations on hours... where should I focus next?

Priorities:

1. ~~Hang on actual website?~~
1. ~~Incorporate new version of data~~
1. Make useful edits to heatmap  
    + add in grouped skill for each item
    + Add ability to switch between number or name or title
1. Incorporate narrative from Greg, Jerry, or Meghan?
1. What else?

:::

Longer term ideas: 

1. Create PDF or Word output from report results
1. Create Shiny app version of this content
1. Create data collection tool



