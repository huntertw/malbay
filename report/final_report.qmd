---
title: "Workload Model"
subtitle: "A summary of the workload model created for this organization"
title-block-banner: true
title-block-style: plain
format:
  html:
    toc: true
    toc-location: left
    toc-title: Contents
    css: styles.css
    code-fold: true
    output-file: 'index'
---


## Introduction

This report provides a summary view of data related to workers, tasks, and hours.

This report has been customized for American Rivers.

## Setup

### Environment


```{r setup}
#| message: false
here::i_am("final_report.qmd")
library(here)
library(ggplot2)
library(dplyr)
library(reactable)
library(reactablefmtr)
library(tippy)
library(ggh4x)
library(patchwork)


cfg <- config::get()

ggplot2::theme_set(theme_bw())

mbcol <- "#1D5F97"
my_pallette <- pals::kelly()[-1]

# TODO
# - add color pallette that aligns to malbay
# - add a label to work items graph to show what each mark means
# - figure out why rendering looks a little blurry
# - 90 degree angle of header row on heatmap or some other solution
# - Improve heatmap by
    # - making text smaller?
    # - Add tool tips with totals for columns and rows?
    # - 
# - After I get feedback on each view, start adding in data validation checks
# Can I adjust the scroll to scroll and not jump




# Random info: if prompted for gf pat, use the following two commands, I think
# gitcreds::gitcreds_set() # try just this... does it still ask?
# credentials::set_github_pat()

```

### Reading in Data

There is only a single data set used for this report.
It is organized by Task and Position. 
It provides information about each of these combinations and a quick summary is 
provided below. 

```{r data}

main_dat <- readxl::read_xlsx(here(cfg$datapath, cfg$client_main)) %>% 
  setNames(make.names(names(.)))

glimpse(main_dat)
```



:::{.callout-note}

A second data set could organize cases by tasks, 
with an estimate of how long each task should take. 
This data could be compared to the first data set throughout.


A third data set could provide a similar set of information, 
but summed at the role level.
Again, this data could be compared to the first data set throughout.

:::



```{r}

# # workitems_dat <- readr::read_csv(here(cfg$datapath, cfg$workitems),
# #                                  show_col_types = FALSE)
# 
# workitems_dat <- main_dat %>% 
#   select(Task, Total.Mins.Max, Department.Alignment) %>% 
#   group_by(Task, Department.Alignment) %>% 
#   summarize(Mins.Required = sum(Total.Mins.Max),
#             instances = n())
# 
# glimpse(workitems_dat)

```



```{r}

# workitems_dat <- readr::read_csv(here(cfg$datapath, cfg$workitems),
#                                  show_col_types = FALSE)

# role_dat <- main_dat %>% 
#   select(Current.Position, Total.Mins.Max) %>% 
#   group_by(Current.Position) %>% 
#   summarize(Total.Mins = sum(Total.Mins.Max),
#             Number.Tasks = n())
# 
# glimpse(role_dat)

```


## Preparing Data

This section outlines some data validation checks and a series of adjustments 
that are made to the input data based on global parameters. 

### Validating Data

:::{.callout-important}

This section is really meant for dealing with multiple data sets. 

*Are there any data validation steps we would want to include for this iteration?*


:::


Output from confirming data (probably a table)

- Number rows
- Total hours
- Total roles
- Total tasks
- Sum of planned hours should meet total number of fours after accounting for admin
- Sum of planned hours for each ind should meet expected supply, highlight above or below
- All individuals or roles should be included in the data set 
(placeholder inds can exist for planning)
- Sum of planned hours **within each period (week, month, year, etc.)** should
meet total number of hours after accounting for admin
- Sum of planned hours for **each individual or role within each period**
should meet total number of hours after accounting for administrative activities
- All tasks should be included, even if there is no alignment. 
The latter should be highlighted.
- Each ind's maximum and minimum dates should cover the full timeline. If they 
don't, the fact should be highlighted.

Some of the other generic ideas for this section could include:

- Overall timeline
- Standard work day/week/year
- Percent of worker's time that should be reserved for admin activities
- Total hours available after accounting for admin activities through the timeline
- Full list of workers/roles included in exercise
- Current quality level vs. optimal quality level

Other ideas?

### Adjusting Data

This section will outline any adjustments applied to the input data along with
a summary of any global parameters. 

A quick review of this data suggests a handful of adjustments. 
They include:

1. Adjust to hours
1. Add period column to represent period


```{r}

main_dat <-   main_dat %>% 
  mutate(Total.Hours = round(Total.Mins.Max / 60, 2),
         period = "week")


# Do I need this?
# workitems_dat <- main_dat %>% 
#   select(Task, Total.Hours, Department.Alignment) %>% 
#   group_by(Task, Department.Alignment) %>% 
#   summarize(Hours.Required = sum(Total.Hours),
#             Number.Tasks = n(),
#             .groups = "drop")
# role_dat <- main_dat %>% 
#   select(Current.Position, Total.Hours) %>% 
#   group_by(Current.Position) %>% 
#   summarize(Total.Hours = sum(Total.Hours),
#             Number.Tasks = n(), .groups = "drop")
```


:::{.callout-important}

OTHER IDEAS TO DISCUSS WITH TEAM:

1. Group tasks?

:::




## Views

### Hours by Department Alignment

This first summary view provides the sum of hours by department alignment.
The right side also provides a count of unique roles contributing to the department efforts.

```{r deptmnt}
# prepare data
hours_by_department <- main_dat %>% 
  group_by(Department.Alignment) %>% 
  summarize(Hours = sum(Total.Hours),
            Num.Positions = length(unique(Current.Position))) %>% 
  mutate(Department.Alignment = forcats::fct_infreq(Department.Alignment, w = Hours))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)

leftside <- hours_by_department %>% 
  ggplot(aes(y = forcats::fct_rev(Department.Alignment))) +
  geom_col(aes(x = Hours, fill = Department.Alignment)) +
  labs(title = "Hours by department",
     y = "Task", 
     x = paste0("Hours per ", xlab)) + 
  scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none")
  # scale_fill_brewer(palette = "Set3")

rightside <- hours_by_department %>% 
  ggplot(aes(y = forcats::fct_rev(Department.Alignment))) +
  geom_col(aes(x = Num.Positions, fill = Department.Alignment)) +
  labs(title = "# Positions",
     y = NULL,
     x = "Positions") +
  scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none",
        axis.text.y = element_blank())

leftside + rightside + plot_layout(widths = c(3,1))
```

This second version provides a summary adjusted by the number of roles associated with each department.

:::{.callout-important}

I think I'm going to drop this after the adjustments I made to the graph above.

:::


```{r}
# prepare data
hours_by_department <- main_dat %>% 
  group_by(Department.Alignment) %>% 
  summarize(Hours = sum(Total.Hours),
            num_pos = length(unique(Current.Position)),
            hours_per_position = Hours / num_pos) %>% 
  mutate(Department.Alignment = forcats::fct_infreq(Department.Alignment, w = Hours))

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)

hours_by_department %>% 
  ggplot(aes(y = forcats::fct_rev(Department.Alignment))) +
  geom_col(aes(x = hours_per_position, fill = Department.Alignment)) +
  labs(title = "Hours by department divided by number unique roles",
     y = "Task", 
     x = paste0("Average hours per ", xlab)) + 
  scale_fill_manual(values = my_pallette) +
  theme(legend.position = "none")



```



### Hours by Task and Department

The view provides the hours by task and department.

```{r tskDeptmnt}
#| fig-width: 8.5
#| fig-height: 12
#| column: screen-inset-right

# prepare data
hours_by_item <- main_dat %>% 
  group_by(Task, Department.Alignment) %>% 
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  arrange(desc(Hours)) %>% 
  mutate(Task = forcats::fct_inorder(Task)) 

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# # Create graph
# hours_by_item %>% 
#   ggplot(aes(y = forcats::fct_rev(item))) +
#   geom_col(aes(x = hours),
#            fill = mbcol) +
#   geom_point(aes(x = hours_required)) +
#   labs(title = "Hours by work item",
#        y = "Work item", 
#        x = paste0("Hours per ", xlab))

hours_by_item %>%
  # mutate(over_under_pct = Hours / Hours.Required-1) %>%
  # select(Task, Hours, Department.Alignment) %>%
  ggplot(aes(y = forcats::fct_rev(Task))) +
  geom_col(aes(x = Hours, fill = Department.Alignment)) +
  facet_grid(rows = vars(Department.Alignment), 
             scales = "free_y", space = "free", 
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by task",
     y = "Task",
     x = paste0("Hours per ", xlab)) +
  scale_fill_manual(values = my_pallette) + 
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0))
  
```


### Hours by Task, Position, and Department

The view provides the hours by task and department.

```{r tskPosDept}
#| fig-width: 10
#| fig-height: 13
#| column: screen-inset-right


# prepare data
hours_by_item_role <- main_dat %>%
  # full_join(workitems_dat %>% select(Task, Hours.Required), by = join_by(Task)) %>% 
  # filter(!is.na(Total.Hours)) %>% 
  group_by(Task, Current.Position, Department.Alignment) %>%
  summarize(Hours = sum(Total.Hours), .groups = "drop") %>% 
  # full_join(workitems_dat) %>%
  arrange(desc(Hours)) %>% 
  mutate(item = forcats::fct_inorder(Task)) 

xlab <- unique(main_dat$period)
stopifnot("period must be on the same time frame" = length(xlab) == 1)
  
  
# Create graph
hours_by_item_role %>% 
  ggplot() +
  geom_col(aes(x = Hours, y = Task, fill = Department.Alignment), 
           position = "dodge") +
  facet_nested(rows = vars(Current.Position, Department.Alignment),
             space = "free_y", scale = "free",
             labeller = label_wrap_gen(width = 20, multi_line = TRUE)) +
  labs(title = "Hours by Position and Task",
       y = "Task", 
       x = paste0("Hours per ", xlab)) +
  theme(legend.position = "none",
        strip.text.y.right = element_text(angle=0)) +
  scale_fill_manual(values = my_pallette)



```

### Heatmap

Finally, this view highlights where time is being spent by the team and 
where there are potential gaps.

```{r hm}
#| column: screen-inset-right

# https://glin.github.io/reactable/articles/examples.html#basic-usage

# TODO: 
# Add some data that takes into account higher level work tasks / skills
hm_dat <- main_dat %>% 
  # filter(Current.Position == "Senior Accountant") %>% 
  select(Task, Total.Hours, Current.Position) %>% 
  group_by(Task, Current.Position) %>% 
  summarize(Total.Hours = sum(Total.Hours), .groups = 'drop') %>% 
  tidyr::pivot_wider(names_from = Current.Position, 
                     values_from = Total.Hours) %>% 
  as.data.frame()

hm_dat$`General Counsel`[1] <-  0 # need at least two items with a number

 

with_tooltip <- function(value, tooltip, ...) {
  htmltools::div(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
      tippy(value, tooltip, ...))
}
library(htmltools)

reactable(hm_dat, 
          resizable = TRUE,
          pagination = FALSE,
          bordered = TRUE,
          wrap = FALSE,
                    # width = 2000,
          style = list(fontSize = "0.65rem"),
          defaultColDef = colDef(footer = function(values) sum(values, na.rm = T),
                                 footerStyle = list(fontWeight = "bold"),
                                 minWidth = 50,
                                 style = color_scales(hm_dat, 
                                                      colors = RColorBrewer::brewer.pal(5, "Oranges"))),
          columns = list(
            Task = colDef(minWidth = 150, filterable = TRUE, 
                         sticky = "left", footer = "Total"),
            # There must be a better way to do this...
            # cat(paste0("`", names(hm_dat),
            #            "` = colDef(header = with_tooltip('",names(hm_dat),
            #            "','",names(hm_dat),"'))"),
            #     sep = ",\n")
            # Maybe pass in a function to finish creating this table...?
            `Task` = colDef(header = with_tooltip('Task','Task')),
            `Junior Accountant` = colDef(header = with_tooltip('Junior Accountant','Junior Accountant')),
            `HR Director` = colDef(header = with_tooltip('HR Director','HR Director')),
            `Senior Accountant` = colDef(header = with_tooltip('Senior Accountant','Senior Accountant')),
            `Assistanct of HR and DEIJ` = colDef(header = with_tooltip(
              'Assistanct of HR and DEIJ','Assistanct of HR and DEIJ')),
            `Assoc Director of Contracts and HR` = colDef(header = with_tooltip(
              'Assoc Director of Contracts and HR','Assoc Director of Contracts and HR')),
            `Director of Grants and Financal Analysis` = colDef(header = with_tooltip(
                'Director of Grants and Financal Analysis','Director of Grants and Financal Analysis')),
            `Director of Facilities and Technology` = colDef(header = with_tooltip(
              'Director of Facilities and Technology','Director of Facilities and Technology')),
            `CFO` = colDef(header = with_tooltip('CFO','CFO')),
            `General Counsel` = colDef(header = with_tooltip('General Counsel','General Counsel'))
            )
          )
```


## Next Steps

:::{.callout-important}

Given limitations on hours... where should I focus next?

Priorities:
1. Hang on actual website?
1. Make useful edits to heatmap  
    + add in grouped skill for each item
    + Add ability to switch between number or name or title
1. Incorporate narrative from Greg, Jerry, or Meghan?
1. What else?

:::

Longer term ideas: 
1. Create PDF or Word output from report results
1. Create Shiny app version of this content
1. Create data collection tool



